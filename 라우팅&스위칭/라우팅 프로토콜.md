## 정적 라우팅 설정

정적으로 라우팅 테이블에 입력해서 알게 해주자!


![정적라우팅](https://user-images.githubusercontent.com/67897827/156558979-3b8abce2-4386-42e5-b8d5-927b239a50a3.PNG)

en -> conf t -> ip route (내가 목표로 보낼 네트워크 대역) ( 목표 대역의 서브넷 마스크) (설정하는 방식 두가지인데 첫번째는 나랑 연결되있는 패킷이 가야되는 라우터의 IP주소를 써주거나, 내가 보내줘야되는 나의 인터페이스 번호를 입력 결국 인터페이스에 ip 설정해주기 땜에 두말이 같은말이다.) 
왼쪽 라우터: ip route 192.168.200.0 255.255.255.0 serial 0/1/0 : 이러면 라우팅 테이블에 입력이 된것이다. 즉
월래는 몰랐는데 200번대 대역은 일로 나가야되~라고 알려준거다.
오른쪽 라우터: ip route 192.168.100.0 255.255.255.0 100.100.100.1(주의)

-통신 확인할때 pc의 양쪽에서 핑 보내보기 
-라우터 입장에서 자기와 연결되어 있는 네트워크 대역은 알고 있다.
-관리자 모드에서 show ip route하면 라우팅 테이블 확인할수있다. 직접 연결 네트웍대역은 코드가 C로 정적으로 설정한 경로는 S로 코드가 되어있다.

가기전에 모듈들 달때 FE가 fastethernet 이고 T가 시리얼 포트 모듈이다.
- interface FastEthernet 0/0 가서 ip address (ip주소) (서브넷)
- 시리얼 인터페이스 같은경우 DCE에서 clock rate설정하고 encapsulation 설정(기본적으로 HDLC프로토콜로 되어있다. PPP 나 Frame-Relay 로 설정 할 수 있다.
- line con 0 에대해 exec-timeout 0 0, logging synchronous

## show로 확인하기

1) show version
라우터에 대한 정보확인
2) show running-config
는 전체 설정 내용 확인(RAM위에서 지금 설정하고 있는 내용들)
3) show interface (interface중 하나)
인터페이스에 대한 자세한 정보
이놈을 쓰는 대부분의 이유는 이 인터페이스에 어떤 ip를 할당했나와, 이놈의 상태정보, 동적 라우팅에 필요한 추가적인 다른 변수들 check
- no shutdown으로 활성화 해주면 up이라고 뜨는거 확인해서 통신 
4) show ip interface brief
인터페이스가 많아지면 일일이 다 확인하기 어려우니까 이렇게 하면 라우터에 설정된 인터페이스 정보 알려준다. **만약 통신문제가 있으면 상태가 up up인지 확인 또는 인터페이스에 ip할당 했는지 확인**
5) show controllers serial 0/0
이 명령어로 해당 시리얼 인터페이스가 DCE로 연결됐는지 DTE로 연결됐는지 확인한다. DCE일 경우 clock rate값을 줘야 한다.
6) show ip route
라우팅 테이블 검색. 직접 연결은 C로 되있지만, S는 정적으로 내가 연결해준것이다.

**정적라우팅을 하기 전에 라우터와 직접연결되어 있는 놈이 제대로 연결 되어있는지 확인 먼저 방법은
상태가 up up인지 확인 또는 인터페이스에 ip할당 했는지 확인**

## 동적 라우팅

우선 동적 라우팅 프로토콜은 크게 링크 스테이트와 디스턴스 벡터로 나눌 수 있다.
디스턴스 벡터 대표 -> RIP, 링크 스테이트 -> OSPF , 둘다 -> EIGRP(이놈은 cisco전용)

**1) RIP**
- 목적지까지 가는 라우터의 개수(홉개수)로 최적의 경로를 설정하는 라우팅 프로토콜이다.
- 디스턴스 백터로 최적의 경로를 결정하는 놈의 대표주자. 예를들어 대한민국과 일본사이에 라우터가 3개이고
한국과 미국사이 라우터 1개이면 RIP은 일본가기위해 미국갓다가 돌아오는 비효율적인 방식을 택할것이다.
비율적이다.
- 이놈은 인접한 라우터들끼리 라우팅 테이블을 공유를한다. 주기적으로 라우터들끼리 라우팅테이블 공유하니까
어느 정도 네트웍부하가 있을 수 있다.
- UDP 포트 520번을 사용한다.
- AD 값이 120이다. 어떤 알고리즘을 돌리던 정적으로 정하던 AD값이 있는데 적을수록 그 길을 택해간다.
정적으로 설정한 AD 값이 1이다.
- 정적은 모르는 네트워크 대역 다 설정 해줘야되는데, 이놈은 나랑 연결되어있는 네트워크 대역만 광고를 해주면 된다. 그러면 지들끼리 광고를 돌려 보면서 야~ 그거 쟤가 안데 안데 안데~
- RIP는 Hop-count가 15이다. 대형 네트워크에서는 사용이 불가능
- 변경된게 없어도 30초마다 정보 공유 -> 네트웍 부하 증가 하지만 설정하면 변경될떄만 할 수!도 있다.
- 네트워크 변화가 생기고 라우터들이 이를 인식하는 시간은 Convergence Time 이라고 하는데, 이놈은 이게 30초이다. 근데 모든 정보를 알아내는데 30초면 느리다. 이때문에 Routing Loop 라는 문제가 생긴다.
**문제점)**
![RIP 문제 루핑](https://user-images.githubusercontent.com/67897827/156605091-bee5b190-1c45-4bf8-8895-279b1a27c114.PNG)

그림에서 10.4.0.0 대역이 Down되고 난후 라우팅 테이블을 공유받으면 월래는 자기것이어서 알았던 값이므로
안바뀌어야 되는데 C라우팅 테이블을 보면 10.4.0.0 에 홉수 2로 바뀐 정보를 받게 된다.(B에서 1이었으니까 내가 받으면 +1되서 2) 결국 안되는건데 갈 수 있는 놈이라고 생각됨. 또 그것을 30초 지난 후 다시 B한테 공유하면 B의 저 대역대의 Hop이 1추가 된다.. 이런식으로 무한 Loop가 형성된다. 그 후 15가 넘으면 못간다 생각
**해결책)**
1) Split Horizon : 처음 정보를 받은 놈한테 다시 정보를 받지 못하게 만드는것.
2) Route Poisoning : 특정 대역이 Down되면 인접놈한테 바로 16으로 세팅해서 알려줘버린다.
3) Hold-Down Timer : 만약 장애가 발생한 네트워크로 부터 정보를 받게 되면 일정시간동안 적용안시키고 무시하고 대기한다. RIP는 컨버젼스 타임에 6배(180초) 정도 대기하는 상태를 가진다. 이시간동안 메트릭값이 낮은 정보를 받은것만 업데이트 (즉 좀더 최적의 경로를 아는 놈 한테 받은것만 업데이트) 그니까 16홉수 기다릴동안 차라리 180초 기다린다.
4) Triggered Update : 네트워크의 변화가 생겼을때만(Down 된거 말고) 알려주기 즉 변화안생겨도 30초씩 돌아가는거 말고 장애가 생겼을때 그 순간 업데이트를 해서 서로 주고 받을 수 있게. 

## 라우터 CLI 설정
 
en -> conf t -> hostname R1 -> (기본설정) no ip domain-lookup, line console 0 (->) exec-timeout 0 0
, logging synchronous (->) exit -> int fastEthernet 0/0 -> ip add 162.10.1.1 255.255.255.0 -> no shutdowm -> exit -> int serial 0/1/0 -> ip add 211.100.10.1 255.255.255.252 -> clock rate 64000 -> encapsulation ppp -> no shutdown -> exit -> show ip int b 로 확인

만약에 ip 설정 잘못했으면 (자기가 잘못 입력한곳 들어가서 지우고 다시 만들기)
conf t -> int seial 0/1/0 -> no ip address -> shutdown -> exit -> int serial 0/1/1 -> ip address 201.100.1.2 255.255.255.252 -> encapsulation ppp -> no shutdown

**정적라우팅 말고 설정을 RIP로 해보자!!**
conf t -> router rip (이러면 프롬프트가 config-router로 변경될거다) -> (이 후 나랑 직접 연결되있는 네트워크 대역을 광고해준다. class에 맞춰서) network 162.10.0.0(B클라스니까 두번째까지) -> network 211.100.10.0

근데 RIP v1같은 경우에는 classful 라우팅 프로토콜이기 때문에 서브넷팅,VLSM,CIDR을 지원하지 못해서 서브넷으로 쓰고있는 다른 네트웍대역을 class하게 인식해 같다고 생각한다. 그래서 v2가 나왔다.

conf t -> router rip -> version 2 -> no auto-summary (auto-summary는 네트워크대역이 쪼개져 있을때 자동으로 합쳐주는 것이다. 즉 no를 해주지 않으면 주소가 정확하지 않아 라우터에서 오락가락 한다. ) -> network 162.10.0.0(classful하게해도 되고 있는거 그대로 써도 된다.)


