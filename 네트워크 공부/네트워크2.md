## ARP 프로토콜
ARP 프로토콜은 같은 네트워크 대역에서 통신을 하기 위해 필요한 MAC주소를 IP주소를 이용해서 알아오는 프로토콜이다. 즉 MAC주소 모르고 IP주소만 알아도
ARP를 통해서 통신이 가능하다.
- ARP요청을 보낼때 목적지 MAC주소를 모르기 때문에 0으로 채우고 캡슐화의 이더넷 프로토콜에서는 브로드캐스트로(모르니까) 다 보내본다.
동일한 ip주소를 받은 놈은 arp 프로토콜 내용을 채워서(op코드 2응답으로) 보내줌

## 멀리있는 컴퓨터끼리 통신
**IPv4**
- 다른 네트워크 상에서 데이터를 교환하기 위한 프로토콜
- 데이터가 정확하게 전달될 것을 보장하지 않는다.(단순히 멀리 보내는 역활만, 신뢰있는 통신은 4계층)

![ip프로토콜](https://user-images.githubusercontent.com/67897827/157647231-23faa559-3ade-40fd-b4ce-28a481e4b892.PNG)

맨앞 버젼은 4가오고, 헤더길이:최소 20바이트~(옵션붙으면 최대 60바이트) 근데 이걸 4비트로 표현하는데 표현최대가 15니까(엥?길이가 20~60이래며?-> 그래서 /4한것을 쓴다.)
Tos:이건 옜날에 쓰던 같이여서 지금은 0으로 비워둠, 다음 전체길이(페이로드 포함),Identification과Flag와Fragment는 데이터가 큰걸보낼때 쪼개서 보내는데 그때 서로를 알아볼수 있게
하는 값들 Identification는 하나가 나눠진 여러놈들을 id값을 줘서 같은 놈이라는걸 알아보려고, IP Flags는 3비트로 D와M있는데 D는 안쪼갠다는 것이고(이놈을 1로하면 안보내지기땜에
안쓰인다 생각) M은 모어 프레그테이션으로 뒤에 나말고 다른 frag가 더있어서 기다려야 된다고 알려주는거. Fragment Offset은 데이터 복구할때 붙이는 순서가 있을텐데(쪼개 보낸다고 순서대로
도착하지 않으니까)그것을 구분 할 수 있게 해주는거 추가적으로 it에서 offset이라고 한다면 뭘 기준으로 얼마 떨어져있다를 나타냄, TTL은 만약 라우팅 설계를 잘못했을때 패킷이 계속 살아서
쌓여있으면 안되니까 언제가는 없어져야 되는데 그 언제가의 시간을 TTL로 적어준다. 시간 느낌이라기 보다 TTL이 0이 되면 버려버림(라우터 한개 건널때마다 한개씩 준다.) TTL만 가지고도
운영체제를 알수 있다. Protocol은 상위 프로토콜이뭐냐, ip입장에서 상위 프로토콜은 icmp,udp,tcp등등..,헤더 체크썸은 헤더가 오류가 있는지 확인해준다.

**ICMP 프로토콜**
- 인터넷 제어 메시지 프로토콜
- 대부분 이용하는 곳이 상대방이랑 통신이 되나 안되나 확인할때
- 여기선 타입이 중요! 대표적으로 0:에코 응답 8:에코요청 3: 목적지 도착 못함(가는 경로상의 문제) 11: 시간 초과(상대방이 뭔가 문제, 상대방의 방화벽정도..) 5:redirect (라우팅 경로 남의
껏을 수정할수 있다. 그럼 나쁜짓 할 수 있기에 보안상 중요!!)


## 라우팅 테이블
- 일단 자기와 연결되어있지 않는 놈의 대역을 라우팅테이블에 정적라우팅하든 동적라우팅하든 알고있게 하는 작업을 먼저 
- 게이트웨이나 라우터는 두 LAN대역이 같이 맞물려 있는 것이다.

![멀리있는 통신](https://user-images.githubusercontent.com/67897827/157660174-528e4888-9c76-492e-bada-e956421d2e65.PNG)

이 사진을 분석해보면, A pc에서 icmp통신 확인을 할때  이더넷 프로토콜의 목적지 주소는 cc:cc:cc:cc:cc:cc이다 이더넷은 다른 대역대를 못감으로(만약여기서 저 게이트웨이의 맥주소를 
모르면 arp프로토콜로 또 알아오는 작업이 필요) 또 그것을 받은 게이트웨이는 자신의 라우팅 테이블을 확인해 목적지 ip에게 가려면 어딜로 가는지 확인
그러면 **이더넷 프로토콜의 목적지 주소를 22:22:22:22:22:22로 바꿔서 다시 작성해서 옆에 놈한테 보내고** 이작업을 반복해서 최종 목적지 까지 도달하게 된다.

## 조각화
만약에 데이터가 2000바이트이고 MTU가 1500이라고 하면 20바이트는 ip프로토콜로 남겨두고 1480과 520으로 나눈다.
또 프로토콜로안의 offset은 1480(앞에 20 안붙인거다)을 8로나눈 값으로 offset을 정하고 flag부분은 뒤가 있으면 1 없으면 0으로 해서 쓰이게된다.

![조각화](https://user-images.githubusercontent.com/67897827/157666498-a6206349-af8a-44e8-8e89-baed8bef4c6b.PNG)

시점을 잘 보면 ipv4가 붙고 고르고 이더넷 프로토콜을 붙인다.

## 4계층
- 전송 계층은 송신자의 프로세스와 수신자의 프로세스를 연결하는 통신 서비스를 제공한다.(프로세스라 하면 메모리에 올라와있는 프로그램들 즉 예를들어 내가 카톡으로 쪽지보냈는데,
상대방 네이트온에 쪽지 오면 안되니까)
- 4계층에서 사용하는 주소느낌으로 포트번호라는 것이 있다. 내 컴퓨에서 사용하는 특정 프로그램이 이 주소를 사용!! 프로그램 하나가 포트번호 1개만 쓸 수 있다.
(내 컴퓨터 기준에서 하나의 포트번호는 하나의 프로그램밖에 실행못하는데,상대방 컴퓨터의 여러가지 프로그램들은 내꺼 1개와 다 연결 할 수있다.)(예를들어 네이버 서버에서도 80번이라는
포트 사용해서 웹서비스 제공 우린 HTTP로 80부 찾아가는 거다)
**Well-Known(무조건 고정되어 있는 포트번호들은 아니다)**
-  FTP:20,21번 SSH:22번, TELNET:23번 , DNS:53번, DHCP:67,68번 , TFTP:69번, HTTP:80번, HTTPS:443번     
Dynamic 포트
- 프로그램과 프로그램이 연결된다 했는데 이 포트번호는 그 프로그램에 접속하는 사용자들이 쓰는 남는 포트번호

UDP를 사용서비스는 DNS서버,TFTP서버, RIP프로토콜


